<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GPU Particle Morphing - Next Level</title>
    <style>
      *,
      *::before,
      *::after {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        width: 100%;
        height: 100vh;
        overflow: hidden;
        background: #000;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
      }

      #container {
        width: 100%;
        height: 100%;
        position: relative;
      }

      #ui {
        position: absolute;
        top: 30px;
        right: 30px;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        color: white;
        z-index: 1000;
        gap: 15px;
      }

      #controls {
        position: absolute;
        top: 30px;
        left: 30px;
        color: white;
        z-index: 1000;
      }

      .control-group {
        background: rgba(10, 10, 10, 0.8);
        backdrop-filter: blur(20px);
        padding: 20px;
        border-radius: 20px;
        margin-bottom: 20px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      }

      .slider-container {
        margin: 15px 0;
      }

      .slider-container label {
        display: block;
        margin-bottom: 8px;
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: rgba(255, 255, 255, 0.8);
      }

      .slider-container span {
        color: #ff5900;
        font-weight: 600;
      }

      input[type="range"] {
        width: 220px;
        height: 6px;
        border-radius: 3px;
        background: rgba(255, 255, 255, 0.1);
        outline: none;
        -webkit-appearance: none;
        appearance: none;
        cursor: pointer;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #ff5900;
        cursor: pointer;
        box-shadow: 0 0 10px rgba(255, 89, 0, 0.5);
        transition: all 0.2s ease;
      }

      input[type="range"]::-webkit-slider-thumb:hover {
        transform: scale(1.2);
        box-shadow: 0 0 20px rgba(255, 89, 0, 0.8);
      }

      input[type="color"] {
        width: 60px;
        height: 35px;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        background: transparent;
      }

      #title {
        font-size: 36px;
        font-weight: 800;
        margin-bottom: 10px;
        text-shadow: 0 0 20px rgba(255, 89, 0, 0.5);
        background: linear-gradient(135deg, #ff5900, #ff9a00);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        letter-spacing: 2px;
      }

      .button {
        cursor: pointer;
        padding: 15px 25px;
        border: 2px solid transparent;
        border-radius: 15px;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.05),
          rgba(255, 255, 255, 0)
        );
        backdrop-filter: blur(10px);
        color: #fff;
        font-size: 15px;
        font-weight: 600;
        letter-spacing: 1px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        min-width: 160px;
        text-align: center;
        position: relative;
        overflow: hidden;
      }

      .button::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        transition: left 0.5s;
      }

      .button:hover {
        background: linear-gradient(
          135deg,
          rgba(255, 89, 0, 0.2),
          rgba(255, 89, 0, 0.1)
        );
        border-color: rgba(255, 89, 0, 0.5);
        transform: translateY(-2px);
        box-shadow: 0 10px 30px rgba(255, 89, 0, 0.3);
      }

      .button:hover::before {
        left: 100%;
      }

      .button.active {
        background: linear-gradient(
          135deg,
          rgba(255, 89, 0, 0.8),
          rgba(255, 89, 0, 0.6)
        );
        border-color: #ff5900;
        transform: translateY(-2px) scale(1.02);
        box-shadow: 0 15px 40px rgba(255, 89, 0, 0.4);
      }

      #info {
        position: absolute;
        bottom: 30px;
        left: 30px;
        color: rgba(255, 255, 255, 0.6);
        font-size: 13px;
        text-shadow: 0 2px 5px rgba(0, 0, 0, 0.8);
        pointer-events: none;
        letter-spacing: 0.5px;
      }

      .loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 24px;
        color: #ff5900;
        z-index: 2000;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <div id="ui">
      <div id="title">PARTICLE MORPH</div>
      <div class="button" data-shape="angkorwat">ANGKOR WAT</div>
      <div class="button" data-shape="naga">NAGA</div>
      <div class="button" data-shape="modern-satellite">MODERN SAT</div>
      <div class="button" data-shape="drone">DRONE</div>
    </div>

    <div id="controls">
      <div class="control-group">
        <div class="slider-container">
          <label>Particle Size: <span id="sizeValue">3.0</span></label>
          <input
            type="range"
            id="particleSize"
            min="0.5"
            max="10"
            step="0.1"
            value="3.0"
          />
        </div>
        <div class="slider-container">
          <label>Rotation Speed: <span id="speedValue">0.5</span></label>
          <input
            type="range"
            id="rotationSpeed"
            min="-2"
            max="2"
            step="0.1"
            value="0.5"
          />
        </div>
        <div class="slider-container">
          <label>Particle Color:</label>
          <input type="color" id="particleColor" value="#ff5900" />
        </div>
      </div>
      <div class="control-group">
        <div class="slider-container">
          <label>Bloom Intensity: <span id="bloomValue">1.5</span></label>
          <input
            type="range"
            id="bloomStrength"
            min="0"
            max="3"
            step="0.1"
            value="1.5"
          />
        </div>
        <div class="slider-container">
          <label>Motion Trail: <span id="trailValue">0.85</span></label>
          <input
            type="range"
            id="motionTrail"
            min="0"
            max="0.98"
            step="0.01"
            value="0.85"
          />
        </div>
      </div>
    </div>

    <div id="info">
      Click & drag to rotate | Scroll to zoom | Double-click to reset
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
      import { GammaCorrectionShader } from "three/addons/shaders/GammaCorrectionShader.js";

      // Global variables
      let scene, camera, renderer, controls;
      let particleSystem, particleMaterial;
      let composer, bloomPass;
      let clock = new THREE.Clock();
      let selectedButton = null;
      let previousRenderTarget, motionBlurComposer;

      // Particle system parameters
      const PARTICLE_COUNT = 20000;
      let targetPositions = new Float32Array(PARTICLE_COUNT * 3);
      let originalPositions = new Float32Array(PARTICLE_COUNT * 3);
      let morphProgress = 1.0;
      let isMorphing = false;

      // Parameters
      const params = {
        particleSize: 3.0,
        particleColor: new THREE.Color("#ff5900"),
        rotationSpeed: 0.5,
        bloomStrength: 1.5,
        motionTrail: 0.85,
      };

      init();
      animate();

      function init() {
        initScene();
        initLights();
        initControls();
        createParticleSystem();
        initPostProcessing();
        initEventListeners();

        // Set initial shape
        const initialButton = document.querySelector(
          '[data-shape="modern-satellite"]'
        );
        initialButton.classList.add("active");
        selectedButton = initialButton;
        morphToShape("modern-satellite");
      }

      function initScene() {
        // Scene setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000000, 0.01);

        // Camera setup
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(40, 30, 60);
        camera.lookAt(0, 0, 0);

        // Renderer setup
        renderer = new THREE.WebGLRenderer({
          antialias: true,
          powerPreference: "high-performance",
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.getElementById("container").appendChild(renderer.domElement);

        // Motion blur render target
        previousRenderTarget = new THREE.WebGLRenderTarget(
          window.innerWidth,
          window.innerHeight,
          {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat,
          }
        );
      }

      function initLights() {
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(20, 30, 20);
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0xff5900, 0.5, 100);
        pointLight.position.set(0, 0, 0);
        scene.add(pointLight);
      }

      function initControls() {
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 20;
        controls.maxDistance = 150;
        controls.autoRotate = false;
        controls.target.set(0, 0, 0);
      }

      function createParticleSystem() {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const sizes = new Float32Array(PARTICLE_COUNT);
        const randoms = new Float32Array(PARTICLE_COUNT * 4);

        // Initialize with sphere positions
        for (let i = 0; i < PARTICLE_COUNT; i++) {
          const i3 = i * 3;

          // Random values for shader animation
          randoms[i * 4] = Math.random();
          randoms[i * 4 + 1] = Math.random();
          randoms[i * 4 + 2] = Math.random();
          randoms[i * 4 + 3] = Math.random();

          // Initial color
          const hue = 0.05 + Math.random() * 0.1;
          const saturation = 0.8 + Math.random() * 0.2;
          const lightness = 0.5 + Math.random() * 0.3;
          const color = new THREE.Color().setHSL(hue, saturation, lightness);
          colors[i3] = color.r;
          colors[i3 + 1] = color.g;
          colors[i3 + 2] = color.b;

          // Random sizes for variation
          sizes[i] = 0.8 + Math.random() * 0.4;
        }

        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute("size", new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute("randoms", new THREE.BufferAttribute(randoms, 4));

        // Shader material for GPU animation
        particleMaterial = new THREE.ShaderMaterial({
          uniforms: {
            uTime: { value: 0 },
            uSize: { value: params.particleSize },
            uColor: { value: params.particleColor },
            uMorphProgress: { value: 1.0 },
            uTargetPositions: { value: targetPositions },
          },
          vertexShader: `
                    uniform float uTime;
                    uniform float uSize;
                    uniform float uMorphProgress;
                    
                    attribute float size;
                    attribute vec4 randoms;
                    attribute vec3 color;
                    
                    varying vec3 vColor;
                    varying float vAlpha;
                    
                    void main() {
                        // Base position with subtle animation
                        vec3 pos = position;
                        
                        // Add subtle floating animation
                        pos += vec3(
                            sin(uTime * randoms.x + randoms.w * 6.28) * 0.1,
                            cos(uTime * randoms.y + randoms.w * 6.28) * 0.1,
                            sin(uTime * randoms.z + randoms.w * 6.28) * 0.1
                        ) * (1.0 - uMorphProgress * 0.5);
                        
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        
                        // Size attenuation
                        float sizeAttenuation = 300.0 / -mvPosition.z;
                        gl_PointSize = uSize * size * sizeAttenuation;
                        
                        // Color variation
                        vColor = color;
                        vAlpha = 0.8 + sin(uTime * randoms.x) * 0.2;
                    }
                `,
          fragmentShader: `
                    uniform vec3 uColor;
                    
                    varying vec3 vColor;
                    varying float vAlpha;
                    
                    void main() {
                        // Circular particle shape with soft edges
                        vec2 center = vec2(0.5);
                        float dist = distance(gl_PointCoord, center);
                        
                        if (dist > 0.5) discard;
                        
                        // Soft edge falloff
                        float strength = 1.0 - smoothstep(0.0, 0.5, dist);
                        strength = pow(strength, 2.0);
                        
                        // Final color with glow effect
                        vec3 finalColor = mix(uColor, vColor, 0.5);
                        finalColor = pow(finalColor * 1.2, vec3(0.8)); // Brighten and adjust gamma
                        
                        gl_FragColor = vec4(finalColor, strength * vAlpha);
                    }
                `,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
        });

        particleSystem = new THREE.Points(geometry, particleMaterial);
        scene.add(particleSystem);
      }

      function initPostProcessing() {
        // Main composer
        composer = new EffectComposer(renderer);

        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Bloom pass for glow effect
        bloomPass = new UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          params.bloomStrength,
          0.4,
          0.85
        );
        composer.addPass(bloomPass);

        // Gamma correction
        const gammaCorrectionPass = new ShaderPass(GammaCorrectionShader);
        composer.addPass(gammaCorrectionPass);

        // Motion blur pass
        const motionBlurShader = {
          uniforms: {
            tDiffuse: { value: null },
            tPrevious: { value: previousRenderTarget.texture },
            uBlendFactor: { value: params.motionTrail },
          },
          vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
          fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform sampler2D tPrevious;
                    uniform float uBlendFactor;
                    varying vec2 vUv;
                    
                    void main() {
                        vec4 current = texture2D(tDiffuse, vUv);
                        vec4 previous = texture2D(tPrevious, vUv);
                        
                        gl_FragColor = mix(current, previous, uBlendFactor);
                    }
                `,
        };

        const motionBlurPass = new ShaderPass(motionBlurShader);
        composer.addPass(motionBlurPass);
      }

      function morphToShape(shape) {
        const positions = particleSystem.geometry.attributes.position.array;

        // Store current positions
        for (let i = 0; i < positions.length; i++) {
          originalPositions[i] = positions[i];
        }

        // Generate target positions based on shape
        switch (shape) {
          case "angkorwat":
            generateAngkorWat();
            break;
          case "naga":
            generateNaga();
            break;
          case "modern-satellite":
            generateModernSatellite();
            break;
          case "drone":
            generateDrone();
            break;
        }

        morphProgress = 0;
        isMorphing = true;
      }

      function generateModernSatellite() {
        const points = [];
        const scale = 1.0;

        // Modern GPS/Communication satellite design
        // Main bus (hexagonal body)
        const busRadius = 4;
        const busHeight = 8;
        const sides = 6;

        // Hexagonal main body
        for (let h = -busHeight / 2; h <= busHeight / 2; h += 0.3) {
          for (let side = 0; side < sides; side++) {
            const angle1 = (side / sides) * Math.PI * 2;
            const angle2 = ((side + 1) / sides) * Math.PI * 2;

            // Face edges
            for (let t = 0; t <= 1; t += 0.1) {
              const x1 = Math.cos(angle1) * busRadius;
              const z1 = Math.sin(angle1) * busRadius;
              const x2 = Math.cos(angle2) * busRadius;
              const z2 = Math.sin(angle2) * busRadius;

              const x = x1 + (x2 - x1) * t;
              const z = z1 + (z2 - z1) * t;

              points.push(new THREE.Vector3(x * scale, h * scale, z * scale));

              // Interior structure
              if (Math.abs(h) < busHeight / 2 - 0.5) {
                points.push(
                  new THREE.Vector3(x * 0.8 * scale, h * scale, z * 0.8 * scale)
                );
              }
            }
          }
        }

        // Large rectangular solar arrays (deployable wings)
        const solarArrayWidth = 25;
        const solarArrayHeight = 15;
        const arrayThickness = 0.3;
        const arrayOffset = busRadius + 3;

        // Left solar array
        for (
          let x = -arrayOffset - solarArrayWidth;
          x <= -arrayOffset;
          x += 0.5
        ) {
          for (
            let y = -solarArrayHeight / 2;
            y <= solarArrayHeight / 2;
            y += 0.5
          ) {
            for (let z = -arrayThickness; z <= arrayThickness; z += 0.2) {
              points.push(new THREE.Vector3(x * scale, y * scale, z * scale));
            }

            // Solar cell grid pattern
            if (Math.abs(x % 3) < 0.5 && Math.abs(y % 3) < 0.5) {
              for (let detail = 0; detail < 4; detail++) {
                points.push(
                  new THREE.Vector3(
                    x * scale + (Math.random() - 0.5) * 0.4,
                    y * scale + (Math.random() - 0.5) * 0.4,
                    (Math.random() - 0.5) * 0.3 * scale
                  )
                );
              }
            }
          }
        }

        // Right solar array
        for (
          let x = arrayOffset;
          x <= arrayOffset + solarArrayWidth;
          x += 0.5
        ) {
          for (
            let y = -solarArrayHeight / 2;
            y <= solarArrayHeight / 2;
            y += 0.5
          ) {
            for (let z = -arrayThickness; z <= arrayThickness; z += 0.2) {
              points.push(new THREE.Vector3(x * scale, y * scale, z * scale));
            }

            // Solar cell grid pattern
            if (Math.abs(x % 3) < 0.5 && Math.abs(y % 3) < 0.5) {
              for (let detail = 0; detail < 4; detail++) {
                points.push(
                  new THREE.Vector3(
                    x * scale + (Math.random() - 0.5) * 0.4,
                    y * scale + (Math.random() - 0.5) * 0.4,
                    (Math.random() - 0.5) * 0.3 * scale
                  )
                );
              }
            }
          }
        }

        // Solar array support booms
        const boomLength = 4;
        const boomSections = 8;

        // Left boom
        for (let section = 0; section < boomSections; section++) {
          const t = section / boomSections;
          const x = -busRadius - t * boomLength;

          // Telescopic boom structure
          const boomRadius = 0.3 - t * 0.1;
          for (let angle = 0; angle < Math.PI * 2; angle += 0.3) {
            const boomY = Math.cos(angle) * boomRadius;
            const boomZ = Math.sin(angle) * boomRadius;
            points.push(
              new THREE.Vector3(x * scale, boomY * scale, boomZ * scale)
            );
          }

          // Connection joints
          if (section % 2 === 0) {
            for (let joint = 0; joint < 8; joint++) {
              const jointAngle = (joint / 8) * Math.PI * 2;
              const jointRadius = boomRadius * 1.5;
              points.push(
                new THREE.Vector3(
                  x * scale,
                  Math.cos(jointAngle) * jointRadius * scale,
                  Math.sin(jointAngle) * jointRadius * scale
                )
              );
            }
          }
        }

        // Right boom
        for (let section = 0; section < boomSections; section++) {
          const t = section / boomSections;
          const x = busRadius + t * boomLength;

          const boomRadius = 0.3 - t * 0.1;
          for (let angle = 0; angle < Math.PI * 2; angle += 0.3) {
            const boomY = Math.cos(angle) * boomRadius;
            const boomZ = Math.sin(angle) * boomRadius;
            points.push(
              new THREE.Vector3(x * scale, boomY * scale, boomZ * scale)
            );
          }

          if (section % 2 === 0) {
            for (let joint = 0; joint < 8; joint++) {
              const jointAngle = (joint / 8) * Math.PI * 2;
              const jointRadius = boomRadius * 1.5;
              points.push(
                new THREE.Vector3(
                  x * scale,
                  Math.cos(jointAngle) * jointRadius * scale,
                  Math.sin(jointAngle) * jointRadius * scale
                )
              );
            }
          }
        }

        // High-gain directional antenna dish
        const dishRadius = 3.5;
        const dishDepth = 1.2;
        const dishPosition = { x: 0, y: busHeight / 2 + 3, z: 0 };

        // Parabolic reflector dish
        for (let angle = 0; angle < Math.PI * 2; angle += 0.04) {
          for (let r = 0; r <= dishRadius; r += 0.15) {
            const parabolaDepth =
              (r / dishRadius) * (r / dishRadius) * dishDepth;
            const x = dishPosition.x + Math.cos(angle) * r;
            const y = dishPosition.y + parabolaDepth;
            const z = dishPosition.z + Math.sin(angle) * r;
            points.push(new THREE.Vector3(x * scale, y * scale, z * scale));

            // Dish surface mesh pattern
            if (r > 0.5 && angle % 0.4 < 0.08) {
              points.push(
                new THREE.Vector3(x * scale, (y - 0.05) * scale, z * scale)
              );
            }
          }
        }

        // Dish feed horn and support structure
        const feedHornHeight = 1.5;
        for (let h = 0; h < feedHornHeight; h += 0.1) {
          const feedRadius = 0.2 + h * 0.1;
          for (let angle = 0; angle < Math.PI * 2; angle += 0.2) {
            const x = dishPosition.x + Math.cos(angle) * feedRadius;
            const y = dishPosition.y + dishDepth + h;
            const z = dishPosition.z + Math.sin(angle) * feedRadius;
            points.push(new THREE.Vector3(x * scale, y * scale, z * scale));
          }
        }

        // Multiple omnidirectional antennas
        const omniAntennas = [
          { x: 2, y: busHeight / 2 + 1, z: 3, height: 4 },
          { x: -2, y: busHeight / 2 + 1, z: 3, height: 3.5 },
          { x: 3, y: busHeight / 2 + 1, z: -2, height: 3 },
          { x: -3, y: busHeight / 2 + 1, z: -2, height: 3.8 },
        ];

        for (let antenna of omniAntennas) {
          // Whip antenna rod
          for (let h = 0; h < antenna.height; h += 0.1) {
            points.push(
              new THREE.Vector3(
                antenna.x * scale,
                (antenna.y + h) * scale,
                antenna.z * scale
              )
            );

            // Helical coil elements
            if (h % 0.5 < 0.1) {
              const coilRadius = 0.3;
              for (
                let coilAngle = 0;
                coilAngle < Math.PI * 2;
                coilAngle += 0.5
              ) {
                const coilX = antenna.x + Math.cos(coilAngle) * coilRadius;
                const coilZ = antenna.z + Math.sin(coilAngle) * coilRadius;
                points.push(
                  new THREE.Vector3(
                    coilX * scale,
                    (antenna.y + h) * scale,
                    coilZ * scale
                  )
                );
              }
            }
          }

          // Antenna base mounting
          const baseRadius = 0.6;
          const baseHeight = 0.8;
          for (let h = 0; h < baseHeight; h += 0.1) {
            for (let angle = 0; angle < Math.PI * 2; angle += 0.3) {
              const x = antenna.x + Math.cos(angle) * baseRadius;
              const y = antenna.y - baseHeight + h;
              const z = antenna.z + Math.sin(angle) * baseRadius;
              points.push(new THREE.Vector3(x * scale, y * scale, z * scale));
            }
          }
        }

        // Attitude control thrusters
        const thrusters = [
          { x: 0, y: -busHeight / 2 - 0.5, z: busRadius + 1 },
          { x: busRadius + 1, y: -busHeight / 2 - 0.5, z: 0 },
          { x: -busRadius - 1, y: -busHeight / 2 - 0.5, z: 0 },
          { x: 0, y: -busHeight / 2 - 0.5, z: -busRadius - 1 },
        ];

        for (let thruster of thrusters) {
          // Thruster nozzle cluster
          const nozzleCount = 4;
          const clusterRadius = 0.8;

          for (let nozzle = 0; nozzle < nozzleCount; nozzle++) {
            const nozzleAngle = (nozzle / nozzleCount) * Math.PI * 2;
            const nozzleX = thruster.x + Math.cos(nozzleAngle) * clusterRadius;
            const nozzleZ = thruster.z + Math.sin(nozzleAngle) * clusterRadius;

            // Individual nozzle
            const nozzleLength = 1.2;
            const nozzleRadius = 0.2;

            for (let h = 0; h < nozzleLength; h += 0.1) {
              const radius = nozzleRadius * (1 - (h / nozzleLength) * 0.3);
              for (let angle = 0; angle < Math.PI * 2; angle += 0.4) {
                const x = nozzleX + Math.cos(angle) * radius;
                const y = thruster.y - h;
                const z = nozzleZ + Math.sin(angle) * radius;
                points.push(new THREE.Vector3(x * scale, y * scale, z * scale));
              }
            }
          }
        }

        // Equipment bays and instrument platforms
        const equipmentBays = [
          { x: 0, y: 2, z: busRadius - 1, width: 3, height: 2, depth: 1.5 },
          { x: busRadius - 1, y: 0, z: 0, width: 1.5, height: 3, depth: 2 },
          { x: -busRadius + 1, y: 0, z: 0, width: 1.5, height: 3, depth: 2 },
        ];

        for (let bay of equipmentBays) {
          // Equipment housing
          for (let x = -bay.width; x <= bay.width; x += 0.3) {
            for (let y = -bay.height; y <= bay.height; y += 0.3) {
              for (let z = -bay.depth; z <= bay.depth; z += 0.3) {
                const isExterior =
                  Math.abs(x) > bay.width - 0.4 ||
                  Math.abs(y) > bay.height - 0.4 ||
                  Math.abs(z) > bay.depth - 0.4;

                if (isExterior) {
                  points.push(
                    new THREE.Vector3(
                      (bay.x + x) * scale,
                      (bay.y + y) * scale,
                      (bay.z + z) * scale
                    )
                  );
                }
              }
            }
          }

          // Thermal radiator fins
          if (bay.x === 0) {
            // Front bay gets radiator
            const finCount = 6;
            for (let fin = 0; fin < finCount; fin++) {
              const finX = bay.x + (fin - finCount / 2) * 0.8;
              const finHeight = 3;

              for (let h = 0; h < finHeight; h += 0.2) {
                points.push(
                  new THREE.Vector3(
                    finX * scale,
                    (bay.y + bay.height + h) * scale,
                    (bay.z + bay.depth + 0.5) * scale
                  )
                );
              }
            }
          }
        }

        // Star tracker and earth sensor instruments
        const instruments = [
          {
            x: busRadius * 0.7,
            y: busHeight / 2 - 1,
            z: busRadius * 0.7,
            type: "star_tracker",
          },
          {
            x: -busRadius * 0.7,
            y: busHeight / 2 - 1,
            z: busRadius * 0.7,
            type: "star_tracker",
          },
          {
            x: 0,
            y: -busHeight / 2 + 1,
            z: busRadius - 0.5,
            type: "earth_sensor",
          },
        ];

        for (let instrument of instruments) {
          if (instrument.type === "star_tracker") {
            // Cylindrical star tracker
            const trackerRadius = 0.4;
            const trackerLength = 1.0;

            for (let h = 0; h < trackerLength; h += 0.1) {
              for (let angle = 0; angle < Math.PI * 2; angle += 0.3) {
                const x = instrument.x + Math.cos(angle) * trackerRadius;
                const y = instrument.y + h;
                const z = instrument.z + Math.sin(angle) * trackerRadius;
                points.push(new THREE.Vector3(x * scale, y * scale, z * scale));
              }
            }

            // Lens cover
            const lensRadius = trackerRadius * 1.2;
            for (let angle = 0; angle < Math.PI * 2; angle += 0.2) {
              const x = instrument.x + Math.cos(angle) * lensRadius;
              const y = instrument.y + trackerLength;
              const z = instrument.z + Math.sin(angle) * lensRadius;
              points.push(new THREE.Vector3(x * scale, y * scale, z * scale));
            }
          } else if (instrument.type === "earth_sensor") {
            // Conical earth sensor
            const sensorRadius = 0.6;
            const sensorHeight = 0.8;

            for (let h = 0; h < sensorHeight; h += 0.1) {
              const radius = sensorRadius * (1 - (h / sensorHeight) * 0.5);
              for (let angle = 0; angle < Math.PI * 2; angle += 0.3) {
                const x = instrument.x + Math.cos(angle) * radius;
                const y = instrument.y + h;
                const z = instrument.z + Math.sin(angle) * radius;
                points.push(new THREE.Vector3(x * scale, y * scale, z * scale));
              }
            }
          }
        }

        distributePointsToParticles(points);
      }

      function generateDrone() {
        const points = [];
        const scale = 1.2;

        // Central body/frame - main hub
        const bodyRadius = 4;
        const bodyHeight = 2;

        // Main central body (cylindrical/rounded)
        for (let y = -bodyHeight; y <= bodyHeight; y += 0.2) {
          for (let angle = 0; angle < Math.PI * 2; angle += 0.05) {
            for (let r = bodyRadius - 1; r <= bodyRadius; r += 0.2) {
              const x = Math.cos(angle) * r;
              const z = Math.sin(angle) * r;
              points.push(new THREE.Vector3(x * scale, y * scale, z * scale));
            }
          }
        }

        // Inner body structure
        for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
          for (let r = 0; r < bodyRadius - 1; r += 0.5) {
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;
            points.push(new THREE.Vector3(x * scale, 0, z * scale));
          }
        }

        // Drone arms - 4 extending from center
        const armLength = 12;
        const armThickness = 0.8;
        const armAngles = [0, Math.PI / 2, Math.PI, (3 * Math.PI) / 2];

        for (let armIndex = 0; armIndex < 4; armIndex++) {
          const armAngle = armAngles[armIndex];

          // Main arm structure
          for (let t = 0; t <= 1; t += 0.02) {
            const armR = bodyRadius + t * armLength;
            const armX = Math.cos(armAngle) * armR;
            const armZ = Math.sin(armAngle) * armR;

            // Arm cross-section (rectangular beam)
            for (
              let thickness = -armThickness;
              thickness <= armThickness;
              thickness += 0.2
            ) {
              for (
                let width = -armThickness;
                width <= armThickness;
                width += 0.2
              ) {
                const perpAngle = armAngle + Math.PI / 2;
                const offsetX = Math.cos(perpAngle) * thickness;
                const offsetZ = Math.sin(perpAngle) * thickness;

                points.push(
                  new THREE.Vector3(
                    (armX + offsetX) * scale,
                    width * scale,
                    (armZ + offsetZ) * scale
                  )
                );
              }
            }

            // Arm reinforcement struts
            if (t > 0.3 && t % 0.2 < 0.05) {
              for (let strut = -1; strut <= 1; strut += 0.2) {
                points.push(
                  new THREE.Vector3(
                    armX * scale,
                    strut * 2 * scale,
                    armZ * scale
                  )
                );
              }
            }
          }
        }

        // Motors and propellers at arm ends
        const motorRadius = 1.5;
        const motorHeight = 2;
        const propellerRadius = 6;
        const propellerThickness = 0.15;

        for (let motorIndex = 0; motorIndex < 4; motorIndex++) {
          const motorAngle = armAngles[motorIndex];
          const motorDistance = bodyRadius + armLength;
          const motorX = Math.cos(motorAngle) * motorDistance;
          const motorZ = Math.sin(motorAngle) * motorDistance;

          // Motor housing
          for (let y = -motorHeight; y <= motorHeight; y += 0.2) {
            for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
              for (let r = motorRadius - 0.3; r <= motorRadius; r += 0.2) {
                const x = motorX + Math.cos(angle) * r;
                const z = motorZ + Math.sin(angle) * r;
                points.push(new THREE.Vector3(x * scale, y * scale, z * scale));
              }
            }
          }

          // Motor shaft
          for (let shaft = 0; shaft < 1; shaft += 0.1) {
            for (let angle = 0; angle < Math.PI * 2; angle += 0.2) {
              const shaftR = 0.3;
              const x = motorX + Math.cos(angle) * shaftR;
              const z = motorZ + Math.sin(angle) * shaftR;
              const y = motorHeight + shaft;
              points.push(new THREE.Vector3(x * scale, y * scale, z * scale));
            }
          }

          // Propellers (2 blades each)
          for (let blade = 0; blade < 2; blade++) {
            const bladeAngle = motorAngle + blade * Math.PI;

            // Blade shape (tapered from hub to tip)
            for (let t = 0; t <= 1; t += 0.02) {
              const bladeR = t * propellerRadius;
              const bladeWidth = (1 - t * 0.7) * 0.8;
              const twist = (t * Math.PI) / 6; // Blade twist

              for (let w = -bladeWidth; w <= bladeWidth; w += 0.1) {
                for (
                  let thick = -propellerThickness;
                  thick <= propellerThickness;
                  thick += 0.1
                ) {
                  const bladeX =
                    motorX +
                    Math.cos(bladeAngle + twist) * bladeR +
                    Math.cos(bladeAngle + Math.PI / 2) * w;
                  const bladeZ =
                    motorZ +
                    Math.sin(bladeAngle + twist) * bladeR +
                    Math.sin(bladeAngle + Math.PI / 2) * w;
                  const bladeY = motorHeight + 1 + thick;
                  points.push(
                    new THREE.Vector3(
                      bladeX * scale,
                      bladeY * scale,
                      bladeZ * scale
                    )
                  );
                }
              }
            }
          }

          // Propeller hub
          for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
            for (let r = 0; r <= 1; r += 0.2) {
              const x = motorX + Math.cos(angle) * r;
              const z = motorZ + Math.sin(angle) * r;
              points.push(
                new THREE.Vector3(
                  x * scale,
                  (motorHeight + 1) * scale,
                  z * scale
                )
              );
            }
          }
        }

        // Camera gimbal system (front of drone)
        const gimbalX = 0;
        const gimbalY = -bodyHeight - 2;
        const gimbalZ = bodyRadius + 1;

        // Gimbal frame
        const gimbalSize = 2;
        for (let frame = 0; frame < 2; frame++) {
          const frameAngle = frame * Math.PI;
          for (let t = 0; t <= 1; t += 0.05) {
            const frameR = gimbalSize;
            const x = gimbalX + Math.cos(frameAngle + t * Math.PI * 2) * frameR;
            const y = gimbalY + Math.sin(t * Math.PI * 2) * frameR;
            const z = gimbalZ;
            points.push(new THREE.Vector3(x * scale, y * scale, z * scale));
          }
        }

        // Camera body
        const cameraWidth = 1.5;
        const cameraHeight = 1;
        const cameraDepth = 2;

        for (let x = -cameraWidth; x <= cameraWidth; x += 0.2) {
          for (let y = -cameraHeight; y <= cameraHeight; y += 0.2) {
            for (let z = -cameraDepth; z <= cameraDepth; z += 0.2) {
              const isEdge =
                Math.abs(x) > cameraWidth - 0.3 ||
                Math.abs(y) > cameraHeight - 0.3 ||
                Math.abs(z) > cameraDepth - 0.3;
              if (isEdge) {
                points.push(
                  new THREE.Vector3(
                    (gimbalX + x) * scale,
                    (gimbalY + y) * scale,
                    (gimbalZ + z) * scale
                  )
                );
              }
            }
          }
        }

        // Camera lens
        const lensRadius = 0.8;
        for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
          for (let r = 0; r <= lensRadius; r += 0.1) {
            const x = gimbalX + Math.cos(angle) * r;
            const y = gimbalY + Math.sin(angle) * r;
            const z = gimbalZ + cameraDepth;
            points.push(new THREE.Vector3(x * scale, y * scale, z * scale));
          }
        }

        // Landing gear/legs
        const legPositions = [
          { x: 3, z: 3 },
          { x: -3, z: 3 },
          { x: 3, z: -3 },
          { x: -3, z: -3 },
        ];

        for (let leg of legPositions) {
          const legHeight = 4;
          const legThickness = 0.3;

          // Main leg strut
          for (let h = 0; h < legHeight; h += 0.1) {
            for (let thick = 0; thick < 8; thick++) {
              const thickAngle = (thick / 8) * Math.PI * 2;
              const x = leg.x + Math.cos(thickAngle) * legThickness;
              const z = leg.z + Math.sin(thickAngle) * legThickness;
              const y = -bodyHeight - h;
              points.push(new THREE.Vector3(x * scale, y * scale, z * scale));
            }
          }

          // Foot pad
          const footRadius = 1;
          for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
            for (let r = 0; r <= footRadius; r += 0.2) {
              const x = leg.x + Math.cos(angle) * r;
              const z = leg.z + Math.sin(angle) * r;
              const y = -bodyHeight - legHeight;
              points.push(new THREE.Vector3(x * scale, y * scale, z * scale));
            }
          }
        }

        // Electronic components on top
        const components = [
          { x: 0, y: bodyHeight + 1, z: 0, size: 1.5, type: "gps" },
          { x: 2, y: bodyHeight + 0.5, z: 2, size: 0.8, type: "antenna" },
          { x: -2, y: bodyHeight + 0.5, z: 2, size: 0.8, type: "antenna" },
          { x: 0, y: bodyHeight + 0.3, z: -2, size: 1, type: "receiver" },
        ];

        for (let comp of components) {
          if (comp.type === "gps") {
            // GPS module (cylindrical)
            const gpsRadius = comp.size;
            const gpsHeight = 0.8;

            for (let h = 0; h < gpsHeight; h += 0.1) {
              for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
                for (let r = gpsRadius - 0.2; r <= gpsRadius; r += 0.1) {
                  const x = comp.x + Math.cos(angle) * r;
                  const z = comp.z + Math.sin(angle) * r;
                  const y = comp.y + h;
                  points.push(
                    new THREE.Vector3(x * scale, y * scale, z * scale)
                  );
                }
              }
            }
          } else if (comp.type === "antenna") {
            // Antenna rod
            const antennaHeight = 3;
            for (let h = 0; h < antennaHeight; h += 0.1) {
              points.push(
                new THREE.Vector3(
                  comp.x * scale,
                  (comp.y + h) * scale,
                  comp.z * scale
                )
              );
            }
          } else if (comp.type === "receiver") {
            // Receiver box
            for (let x = -comp.size; x <= comp.size; x += 0.2) {
              for (let y = 0; y <= comp.size; y += 0.2) {
                for (let z = -comp.size; z <= comp.size; z += 0.2) {
                  const isEdge =
                    Math.abs(x) > comp.size - 0.2 ||
                    y > comp.size - 0.2 ||
                    Math.abs(z) > comp.size - 0.2;
                  if (isEdge) {
                    points.push(
                      new THREE.Vector3(
                        (comp.x + x) * scale,
                        (comp.y + y) * scale,
                        (comp.z + z) * scale
                      )
                    );
                  }
                }
              }
            }
          }
        }

        // Battery compartment (bottom)
        const batteryWidth = 3;
        const batteryHeight = 1;
        const batteryDepth = 6;
        const batteryY = -bodyHeight - 1;

        for (let x = -batteryWidth; x <= batteryWidth; x += 0.3) {
          for (let y = -batteryHeight; y <= 0; y += 0.2) {
            for (let z = -batteryDepth; z <= batteryDepth; z += 0.3) {
              const isWall =
                Math.abs(x) > batteryWidth - 0.3 ||
                y < -batteryHeight + 0.2 ||
                Math.abs(z) > batteryDepth - 0.3;
              if (isWall) {
                points.push(
                  new THREE.Vector3(
                    x * scale,
                    (batteryY + y) * scale,
                    z * scale
                  )
                );
              }
            }
          }
        }

        // LED lights (navigation/status)
        const ledPositions = [
          { x: bodyRadius, y: 0, z: 0, color: "red" },
          { x: -bodyRadius, y: 0, z: 0, color: "green" },
          { x: 0, y: 0, z: bodyRadius, color: "white" },
          { x: 0, y: 0, z: -bodyRadius, color: "white" },
        ];

        for (let led of ledPositions) {
          // Small LED housings
          const ledSize = 0.3;
          for (let x = -ledSize; x <= ledSize; x += 0.1) {
            for (let y = -ledSize; y <= ledSize; y += 0.1) {
              for (let z = -ledSize; z <= ledSize; z += 0.1) {
                points.push(
                  new THREE.Vector3(
                    (led.x + x) * scale,
                    (led.y + y) * scale,
                    (led.z + z) * scale
                  )
                );
              }
            }
          }
        }

        // Wiring and cables
        const wireRoutes = [
          { start: [0, 0, 0], end: [bodyRadius + armLength, 0, 0] },
          { start: [0, 0, 0], end: [0, 0, bodyRadius + armLength] },
          { start: [0, 0, 0], end: [-bodyRadius - armLength, 0, 0] },
          { start: [0, 0, 0], end: [0, 0, -bodyRadius - armLength] },
          { start: [0, bodyHeight, 0], end: [0, gimbalY, gimbalZ] },
        ];

        for (let wire of wireRoutes) {
          for (let t = 0; t <= 1; t += 0.05) {
            const x = wire.start[0] + (wire.end[0] - wire.start[0]) * t;
            const y = wire.start[1] + (wire.end[1] - wire.start[1]) * t;
            const z = wire.start[2] + (wire.end[2] - wire.start[2]) * t;

            // Main wire
            points.push(new THREE.Vector3(x * scale, y * scale, z * scale));

            // Wire bundle thickness
            for (let bundle = 0; bundle < 3; bundle++) {
              const offset = 0.1;
              points.push(
                new THREE.Vector3(
                  x * scale + (Math.random() - 0.5) * offset,
                  y * scale + (Math.random() - 0.5) * offset,
                  z * scale + (Math.random() - 0.5) * offset
                )
              );
            }
          }
        }

        // Protective motor guards (optional racing-style)
        for (let guardIndex = 0; guardIndex < 4; guardIndex++) {
          const guardAngle = armAngles[guardIndex];
          const guardDistance = bodyRadius + armLength;
          const guardX = Math.cos(guardAngle) * guardDistance;
          const guardZ = Math.sin(guardAngle) * guardDistance;
          const guardRadius = propellerRadius + 1;

          // Ring guard around propeller
          for (let angle = 0; angle < Math.PI * 2; angle += 0.05) {
            for (let thickness = -0.3; thickness <= 0.3; thickness += 0.1) {
              const x = guardX + Math.cos(angle) * guardRadius;
              const z = guardZ + Math.sin(angle) * guardRadius;
              const y = motorHeight + thickness;
              points.push(new THREE.Vector3(x * scale, y * scale, z * scale));
            }
          }
        }

        // Flight controller/IMU sensors
        const fcX = 0;
        const fcY = 0;
        const fcZ = 0;
        const fcSize = 2;

        // Flight controller board
        for (let x = -fcSize; x <= fcSize; x += 0.2) {
          for (let z = -fcSize; z <= fcSize; z += 0.2) {
            // PCB surface
            points.push(
              new THREE.Vector3(
                (fcX + x) * scale,
                (fcY + 0.2) * scale,
                (fcZ + z) * scale
              )
            );

            // Components on board
            if (x % 0.8 < 0.2 && z % 0.8 < 0.2) {
              for (let comp = 0; comp < 3; comp++) {
                points.push(
                  new THREE.Vector3(
                    (fcX + x) * scale,
                    (fcY + 0.2 + comp * 0.1) * scale,
                    (fcZ + z) * scale
                  )
                );
              }
            }
          }
        }

        distributePointsToParticles(points);
      }

      function generateAngkorWat() {
        const points = [];
        const scale = 0.5;

        // Multi-level base platforms (3 tiers) with moat representation
        const platforms = [
          { width: 85, depth: 75, height: 1.5, y: -20 }, // Outer moat edge
          { width: 70, depth: 60, height: 2, y: -19 },
          { width: 55, depth: 45, height: 2, y: -17 },
          { width: 40, depth: 30, height: 2, y: -15 },
        ];

        for (let p = 0; p < platforms.length; p++) {
          const platform = platforms[p];
          for (let x = -platform.width / 2; x <= platform.width / 2; x += 1.2) {
            for (
              let z = -platform.depth / 2;
              z <= platform.depth / 2;
              z += 1.2
            ) {
              // Platform surface with subtle texture
              for (
                let y = platform.y;
                y < platform.y + platform.height;
                y += 0.25
              ) {
                // Add sandstone texture variation
                const textureNoise =
                  Math.sin(x * 0.5) * Math.sin(z * 0.5) * 0.1;
                points.push(
                  new THREE.Vector3(
                    x * scale,
                    (y + textureNoise) * scale,
                    z * scale
                  )
                );
              }

              // Decorative balustrade on platform edges
              if (
                p > 0 &&
                (Math.abs(x) > platform.width / 2 - 2 ||
                  Math.abs(z) > platform.depth / 2 - 2)
              ) {
                // Balustrade posts
                if (Math.floor(x) % 3 === 0 && Math.floor(z) % 3 === 0) {
                  for (let h = 0; h < 1.5; h += 0.1) {
                    points.push(
                      new THREE.Vector3(
                        x * scale,
                        (platform.y + platform.height + h) * scale,
                        z * scale
                      )
                    );
                  }
                }
                // Balustrade rail
                for (let y = platform.y - 0.5; y < platform.y; y += 0.15) {
                  points.push(
                    new THREE.Vector3(x * scale, y * scale, z * scale)
                  );
                }
              }
            }
          }
        }

        // Central tower (prasat) with authentic Khmer architectural details
        function createTower(
          centerX,
          centerY,
          centerZ,
          width,
          height,
          isMain = false
        ) {
          const tiers = isMain ? 9 : 6;

          // Square base with corner indentations (redented square plan)
          for (let tier = 0; tier < tiers; tier++) {
            const tierHeight = height / tiers;
            const tierWidth = width * (1 - tier * 0.12);
            const y0 = centerY + tier * tierHeight;
            const y1 = centerY + (tier + 1) * tierHeight;

            // Tower walls with authentic Khmer profile
            for (let y = y0; y < y1; y += 0.25) {
              // Create redented square shape (cross-shaped floor plan)
              for (let side = 0; side < 4; side++) {
                const sideAngle = (side / 4) * Math.PI * 2;

                // Main wall segments
                for (let t = -0.4; t <= 0.4; t += 0.02) {
                  const wallX =
                    centerX +
                    (Math.cos(sideAngle) * tierWidth) / 2 +
                    Math.cos(sideAngle + Math.PI / 2) * t * tierWidth;
                  const wallZ =
                    centerZ +
                    (Math.sin(sideAngle) * tierWidth) / 2 +
                    Math.sin(sideAngle + Math.PI / 2) * t * tierWidth;
                  points.push(
                    new THREE.Vector3(wallX * scale, y * scale, wallZ * scale)
                  );
                }

                // Corner projections (creating the redented effect)
                const cornerAngle = sideAngle + Math.PI / 4;
                for (let proj = 0; proj < 0.3; proj += 0.05) {
                  const projX =
                    centerX + Math.cos(cornerAngle) * (tierWidth / 2 - proj);
                  const projZ =
                    centerZ + Math.sin(cornerAngle) * (tierWidth / 2 - proj);
                  points.push(
                    new THREE.Vector3(projX * scale, y * scale, projZ * scale)
                  );
                }
              }

              // Vertical pilasters on each face
              for (let i = 0; i < 4; i++) {
                const pilasterAngle = (i / 4) * Math.PI * 2;
                for (let p = -0.3; p <= 0.3; p += 0.15) {
                  const pilasterR = tierWidth / 2 + Math.sin(y * 0.5) * 0.2; // Subtle entasis
                  const px =
                    centerX +
                    Math.cos(pilasterAngle) * pilasterR +
                    (Math.cos(pilasterAngle + Math.PI / 2) * p * tierWidth) / 3;
                  const pz =
                    centerZ +
                    Math.sin(pilasterAngle) * pilasterR +
                    (Math.sin(pilasterAngle + Math.PI / 2) * p * tierWidth) / 3;
                  points.push(
                    new THREE.Vector3(px * scale, y * scale, pz * scale)
                  );
                }
              }
            }

            // Elaborate cornice between tiers
            if (tier < tiers - 1) {
              for (let c = 0; c < 3; c++) {
                const corniceY = y1 + c * 0.2;
                const corniceR = tierWidth / 2 + (2 - c) * 0.3;
                for (let angle = 0; angle < Math.PI * 2; angle += 0.02) {
                  // Antefixes (decorative roof edge ornaments)
                  const antefixPattern = Math.abs(Math.sin(angle * 16)) * 0.2;
                  const x =
                    centerX + Math.cos(angle) * (corniceR + antefixPattern);
                  const z =
                    centerZ + Math.sin(angle) * (corniceR + antefixPattern);
                  points.push(
                    new THREE.Vector3(x * scale, corniceY * scale, z * scale)
                  );
                }
              }
            }

            // Devata (deity) niches on each face
            if (tier > 0 && tier < tiers - 2) {
              for (let i = 0; i < 4; i++) {
                const nicheAngle = (i / 4) * Math.PI * 2;
                const nicheX =
                  centerX + Math.cos(nicheAngle) * tierWidth * 0.48;
                const nicheZ =
                  centerZ + Math.sin(nicheAngle) * tierWidth * 0.48;

                // Niche frame with pediment
                for (let ny = 0; ny < tierHeight * 0.7; ny += 0.15) {
                  // Triangular pediment at top
                  const pedimentWidth =
                    ny < tierHeight * 0.5
                      ? 1.5
                      : 1.5 *
                        (1 - (ny - tierHeight * 0.5) / (tierHeight * 0.2));
                  for (
                    let nx = -pedimentWidth;
                    nx <= pedimentWidth;
                    nx += 0.1
                  ) {
                    points.push(
                      new THREE.Vector3(
                        (nicheX + Math.cos(nicheAngle + Math.PI / 2) * nx) *
                          scale,
                        (y0 + ny) * scale,
                        (nicheZ + Math.sin(nicheAngle + Math.PI / 2) * nx) *
                          scale
                      )
                    );
                  }
                }

                // Devata figure suggestion
                for (let fig = 0; fig < 30; fig++) {
                  const figY =
                    y0 + tierHeight * 0.2 + Math.random() * tierHeight * 0.4;
                  const figOffset = (Math.random() - 0.5) * 0.5;
                  points.push(
                    new THREE.Vector3(
                      (nicheX +
                        Math.cos(nicheAngle + Math.PI / 2) * figOffset) *
                        scale,
                      figY * scale,
                      (nicheZ +
                        Math.sin(nicheAngle + Math.PI / 2) * figOffset) *
                        scale
                    )
                  );
                }
              }
            }
          }

          // Distinctive Khmer-style lotus bud (typical of Angkor Wat towers)
          const topY = centerY + height;

          // Multiple rings forming the bud base
          for (let ring = 0; ring < 4; ring++) {
            const ringY = topY + ring * 0.4;
            const ringR = 2 - ring * 0.3;
            for (let angle = 0; angle < Math.PI * 2; angle += 0.05) {
              const wobble = Math.sin(angle * 8) * 0.1;
              const x = centerX + Math.cos(angle) * (ringR + wobble);
              const z = centerZ + Math.sin(angle) * (ringR + wobble);
              points.push(
                new THREE.Vector3(x * scale, ringY * scale, z * scale)
              );
            }
          }

          // Conical lotus bud shape (closed bud, not open petals)
          for (let h = 0; h < 6; h += 0.1) {
            const budR = (1.5 - h * 0.25) * Math.sin(h * 0.3);
            for (let angle = 0; angle < Math.PI * 2; angle += 0.08) {
              // Vertical ridges on the bud
              const ridgePattern = Math.sin(angle * 12) * 0.15;
              const x = centerX + Math.cos(angle) * (budR + ridgePattern);
              const z = centerZ + Math.sin(angle) * (budR + ridgePattern);
              points.push(
                new THREE.Vector3(
                  x * scale,
                  (topY + 1.5 + h) * scale,
                  z * scale
                )
              );
            }
          }

          // Finial spike at the very top
          for (let h = 0; h < 2; h += 0.1) {
            const spikeR = 0.3 - h * 0.15;
            for (let angle = 0; angle < Math.PI * 2; angle += 0.2) {
              const x = centerX + Math.cos(angle) * spikeR;
              const z = centerZ + Math.sin(angle) * spikeR;
              points.push(
                new THREE.Vector3(
                  x * scale,
                  (topY + 7.5 + h) * scale,
                  z * scale
                )
              );
            }
          }
        }

        // Main central tower - the tallest (reduced height)
        createTower(0, -14, 0, 16, 30, true);

        // Four corner towers in perfect quincunx pattern (forming a square)
        const cornerPositions = [
          [-20, -14, -20],
          [20, -14, -20],
          [-20, -14, 20],
          [20, -14, 20],
        ];

        for (let pos of cornerPositions) {
          createTower(pos[0], pos[1], pos[2], 12, 20);
        }

        // Three concentric rectangular enclosures (as seen in aerial photos)
        const enclosures = [
          { width: 76, depth: 68, wallThickness: 2, height: 10, y: -14 }, // Outer enclosure
          { width: 58, depth: 50, wallThickness: 1.5, height: 8, y: -12 }, // Middle enclosure
          { width: 44, depth: 36, wallThickness: 1, height: 6, y: -10 }, // Inner enclosure
        ];

        for (let enclosure of enclosures) {
          const halfWidth = enclosure.width / 2;
          const halfDepth = enclosure.depth / 2;

          // Create rectangular walls
          for (
            let y = enclosure.y;
            y < enclosure.y + enclosure.height;
            y += 0.25
          ) {
            // North and South walls
            for (let x = -halfWidth; x <= halfWidth; x += 0.4) {
              // North wall
              for (
                let z = halfDepth - enclosure.wallThickness;
                z <= halfDepth;
                z += 0.2
              ) {
                // Window openings pattern
                const windowSpacing = 8;
                const isWindow =
                  Math.floor(x / windowSpacing) % 2 === 0 &&
                  y > enclosure.y + 2 &&
                  y < enclosure.y + enclosure.height - 2;
                if (
                  !isWindow ||
                  y < enclosure.y + 1 ||
                  y > enclosure.y + enclosure.height - 1
                ) {
                  points.push(
                    new THREE.Vector3(x * scale, y * scale, z * scale)
                  );
                }
              }

              // South wall
              for (
                let z = -halfDepth;
                z <= -halfDepth + enclosure.wallThickness;
                z += 0.2
              ) {
                const windowSpacing = 8;
                const isWindow =
                  Math.floor(x / windowSpacing) % 2 === 0 &&
                  y > enclosure.y + 2 &&
                  y < enclosure.y + enclosure.height - 2;
                if (
                  !isWindow ||
                  y < enclosure.y + 1 ||
                  y > enclosure.y + enclosure.height - 1
                ) {
                  points.push(
                    new THREE.Vector3(x * scale, y * scale, z * scale)
                  );
                }
              }
            }

            // East and West walls
            for (
              let z = -halfDepth + enclosure.wallThickness;
              z <= halfDepth - enclosure.wallThickness;
              z += 0.4
            ) {
              // East wall
              for (
                let x = halfWidth - enclosure.wallThickness;
                x <= halfWidth;
                x += 0.2
              ) {
                const windowSpacing = 8;
                const isWindow =
                  Math.floor(z / windowSpacing) % 2 === 0 &&
                  y > enclosure.y + 2 &&
                  y < enclosure.y + enclosure.height - 2;
                if (
                  !isWindow ||
                  y < enclosure.y + 1 ||
                  y > enclosure.y + enclosure.height - 1
                ) {
                  points.push(
                    new THREE.Vector3(x * scale, y * scale, z * scale)
                  );
                }
              }

              // West wall
              for (
                let x = -halfWidth;
                x <= -halfWidth + enclosure.wallThickness;
                x += 0.2
              ) {
                const windowSpacing = 8;
                const isWindow =
                  Math.floor(z / windowSpacing) % 2 === 0 &&
                  y > enclosure.y + 2 &&
                  y < enclosure.y + enclosure.height - 2;
                if (
                  !isWindow ||
                  y < enclosure.y + 1 ||
                  y > enclosure.y + enclosure.height - 1
                ) {
                  points.push(
                    new THREE.Vector3(x * scale, y * scale, z * scale)
                  );
                }
              }
            }
          }

          // Corner pillars
          const corners = [
            [halfWidth - 1, halfDepth - 1],
            [-halfWidth + 1, halfDepth - 1],
            [halfWidth - 1, -halfDepth + 1],
            [-halfWidth + 1, -halfDepth + 1],
          ];

          for (let corner of corners) {
            for (
              let y = enclosure.y;
              y < enclosure.y + enclosure.height;
              y += 0.2
            ) {
              for (let px = -0.5; px <= 0.5; px += 0.2) {
                for (let pz = -0.5; pz <= 0.5; pz += 0.2) {
                  points.push(
                    new THREE.Vector3(
                      (corner[0] + px) * scale,
                      y * scale,
                      (corner[1] + pz) * scale
                    )
                  );
                }
              }
            }
          }

          // Colonnade between walls (inner gallery)
          if (enclosure.width < 60) {
            // Only for inner enclosures
            const colSpacing = 6;
            for (
              let x = -halfWidth + colSpacing;
              x < halfWidth;
              x += colSpacing
            ) {
              for (
                let z = -halfDepth + colSpacing;
                z < halfDepth;
                z += colSpacing
              ) {
                if (Math.abs(x) > 5 || Math.abs(z) > 5) {
                  // Don't place columns too close to center
                  for (
                    let y = enclosure.y;
                    y < enclosure.y + enclosure.height;
                    y += 0.3
                  ) {
                    for (let r = 0; r < 360; r += 45) {
                      const colR = 0.3;
                      const colX = x + Math.cos((r * Math.PI) / 180) * colR;
                      const colZ = z + Math.sin((r * Math.PI) / 180) * colR;
                      points.push(
                        new THREE.Vector3(colX * scale, y * scale, colZ * scale)
                      );
                    }
                  }
                }
              }
            }
          }
        }

        // Cruciform corridors connecting to entrance gates
        const corridorPaths = [
          { start: [0, -34], end: [0, -22], width: 3, direction: "ns" }, // North corridor
          { start: [0, 22], end: [0, 34], width: 3, direction: "ns" }, // South corridor
          { start: [-34, 0], end: [-22, 0], width: 3, direction: "ew" }, // West corridor
          { start: [22, 0], end: [34, 0], width: 3, direction: "ew" }, // East corridor
        ];

        for (let corridor of corridorPaths) {
          const [start, end] = [corridor.start, corridor.end];
          for (let t = 0; t <= 1; t += 0.05) {
            const x = start[0] + (end[0] - start[0]) * t;
            const z = start[1] + (end[1] - start[1]) * t;

            // Corridor walls and vaulted ceiling
            for (let y = -14; y < -14 + 8; y += 0.3) {
              for (
                let offset = -corridor.width;
                offset <= corridor.width;
                offset += 0.3
              ) {
                // Walls
                if (Math.abs(offset) > corridor.width - 0.5 || y < -13) {
                  if (corridor.direction === "ns") {
                    points.push(
                      new THREE.Vector3(
                        (x + offset) * scale,
                        y * scale,
                        z * scale
                      )
                    );
                  } else {
                    points.push(
                      new THREE.Vector3(
                        x * scale,
                        y * scale,
                        (z + offset) * scale
                      )
                    );
                  }
                }

                // Vaulted ceiling
                if (y > -8) {
                  const ceilingCurve = Math.sqrt(
                    Math.max(0, 1 - Math.pow(offset / corridor.width, 2))
                  );
                  const ceilingY = y + ceilingCurve * 2;
                  if (corridor.direction === "ns") {
                    points.push(
                      new THREE.Vector3(
                        (x + offset) * scale,
                        ceilingY * scale,
                        z * scale
                      )
                    );
                  } else {
                    points.push(
                      new THREE.Vector3(
                        x * scale,
                        ceilingY * scale,
                        (z + offset) * scale
                      )
                    );
                  }
                }
              }
            }
          }
        }

        // Iconic Naga balustrades - the most distinctive feature of Angkor Wat
        for (let side = 0; side < 4; side++) {
          const angle = (side / 4) * Math.PI * 2 + Math.PI / 4; // 45-degree offset for corners
          const startR = 40;
          const endR = 50;

          // Naga body with authentic undulating form
          for (let t = 0; t <= 1; t += 0.008) {
            const r = startR + (endR - startR) * t;
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;
            // Classic Khmer Naga undulation
            const y = -17 + Math.sin(t * Math.PI * 4) * 2 + t * 2;

            // Segmented body with pronounced scales
            const bodyThickness = 2 - t * 0.8;
            const segments = 24;
            for (let i = 0; i < segments; i++) {
              const segAngle = (i / segments) * Math.PI * 2;
              // Diamond-shaped cross-section typical of Khmer nagas
              const diamondShape = Math.abs(Math.sin(segAngle * 2)) * 0.3;
              const segmentR = bodyThickness + diamondShape;

              // Scale pattern
              const scalePattern = Math.sin(t * 50 + segAngle * 4) * 0.1;

              const offsetX =
                Math.cos(angle + Math.PI / 2) *
                Math.cos(segAngle) *
                (segmentR + scalePattern);
              const offsetZ =
                Math.sin(angle + Math.PI / 2) *
                Math.cos(segAngle) *
                (segmentR + scalePattern);
              const offsetY = Math.sin(segAngle) * segmentR;

              points.push(
                new THREE.Vector3(
                  (x + offsetX) * scale,
                  (y + offsetY) * scale,
                  (z + offsetZ) * scale
                )
              );
            }

            // Dorsal ridge
            for (let ridge = 0; ridge < 0.5; ridge += 0.1) {
              points.push(
                new THREE.Vector3(
                  x * scale,
                  (y + bodyThickness + ridge) * scale,
                  z * scale
                )
              );
            }
          }

          // Magnificent seven-headed hood (spread in fan formation)
          const hoodX = Math.cos(angle) * endR;
          const hoodZ = Math.sin(angle) * endR;
          const hoodBaseY = -15;

          // Hood necks spreading outward
          for (let head = -3; head <= 3; head++) {
            const spreadAngle = ((head / 6) * Math.PI) / 3; // Fan out 60 degrees
            const neckLength = 8 - Math.abs(head) * 0.5;

            // Each neck
            for (let n = 0; n < neckLength; n += 0.2) {
              const neckT = n / neckLength;
              const neckR = 1.2 - neckT * 0.3;
              const neckX =
                hoodX + Math.cos(angle + Math.PI / 2 + spreadAngle) * n * 0.8;
              const neckZ =
                hoodZ + Math.sin(angle + Math.PI / 2 + spreadAngle) * n * 0.8;
              const neckY = hoodBaseY + n * 0.7 + Math.sin(neckT * Math.PI) * 1;

              for (let a = 0; a < Math.PI * 2; a += 0.15) {
                const x = neckX + Math.cos(a) * neckR;
                const z = neckZ + Math.sin(a) * neckR;
                points.push(
                  new THREE.Vector3(x * scale, neckY * scale, z * scale)
                );
              }
            }

            // Hood cobra head
            const headX =
              hoodX +
              Math.cos(angle + Math.PI / 2 + spreadAngle) * neckLength * 0.8;
            const headZ =
              hoodZ +
              Math.sin(angle + Math.PI / 2 + spreadAngle) * neckLength * 0.8;
            const headY = hoodBaseY + neckLength * 0.7 + 1;

            // Flared cobra hood
            for (let h = -2; h <= 2; h += 0.2) {
              for (let w = -1.5; w <= 1.5; w += 0.2) {
                const hoodFlare = 1 - Math.abs(h) / 2;
                const x =
                  headX +
                  Math.cos(angle + spreadAngle) * h +
                  Math.cos(angle + Math.PI / 2 + spreadAngle) * w * hoodFlare;
                const z =
                  headZ +
                  Math.sin(angle + spreadAngle) * h +
                  Math.sin(angle + Math.PI / 2 + spreadAngle) * w * hoodFlare;
                const y = headY + Math.abs(w) * 0.3;
                points.push(new THREE.Vector3(x * scale, y * scale, z * scale));
              }
            }

            // Crown on central head
            if (head === 0) {
              for (let c = 0; c < 2; c += 0.1) {
                const crownR = 0.5 - c * 0.2;
                for (let a = 0; a < Math.PI * 2; a += 0.3) {
                  const x = headX + Math.cos(a) * crownR;
                  const z = headZ + Math.sin(a) * crownR;
                  points.push(
                    new THREE.Vector3(
                      x * scale,
                      (headY + 2 + c) * scale,
                      z * scale
                    )
                  );
                }
              }
            }
          }
        }

        // Library buildings in corners (without towers - just low structures)
        const libraries = [
          { x: -30, z: -30 },
          { x: 30, z: -30 },
          { x: -30, z: 30 },
          { x: 30, z: 30 },
        ];

        for (let lib of libraries) {
          // Simple library structure without tower
          for (let x = lib.x - 4; x <= lib.x + 4; x += 0.4) {
            for (let z = lib.z - 3; z <= lib.z + 3; z += 0.4) {
              for (let y = -14; y < -14 + 4; y += 0.3) {
                // Create walls only (hollow interior)
                if (
                  Math.abs(x - lib.x) > 3 ||
                  Math.abs(z - lib.z) > 2 ||
                  y < -13.5 ||
                  y > -11
                ) {
                  points.push(
                    new THREE.Vector3(x * scale, y * scale, z * scale)
                  );
                }
              }
            }
          }

          // Simple flat roof (no tower)
          for (let x = lib.x - 4; x <= lib.x + 4; x += 0.5) {
            for (let z = lib.z - 3; z <= lib.z + 3; z += 0.5) {
              points.push(
                new THREE.Vector3(x * scale, (-14 + 4) * scale, z * scale)
              );
            }
          }
        }

        // Bas-relief panels depicting scenes from Ramayana and Mahabharata
        const reliefPanels = [
          { start: 0, end: Math.PI / 2, scene: "battle" },
          { start: Math.PI / 2, end: Math.PI, scene: "procession" },
          { start: Math.PI, end: (3 * Math.PI) / 2, scene: "deities" },
          { start: (3 * Math.PI) / 2, end: 2 * Math.PI, scene: "apsaras" },
        ];

        for (let panel of reliefPanels) {
          for (let a = panel.start; a < panel.end; a += 0.02) {
            const wallR = 36.5;
            const baseX = Math.cos(a) * wallR;
            const baseZ = Math.sin(a) * wallR;

            // Create different patterns for different scenes
            for (let y = -12; y < -4; y += 0.3) {
              for (let depth = 0; depth < 0.5; depth += 0.1) {
                let pattern = 0;
                if (panel.scene === "battle") {
                  pattern = Math.sin(a * 20) * Math.sin(y * 2) * 0.3;
                } else if (panel.scene === "procession") {
                  pattern = Math.sin(a * 30 + y * 0.5) * 0.2;
                } else if (panel.scene === "deities") {
                  pattern = Math.abs(Math.sin(a * 15) * Math.cos(y)) * 0.3;
                } else if (panel.scene === "apsaras") {
                  pattern = Math.sin(a * 25) * Math.cos(y * 3) * 0.25;
                }

                const x = baseX - Math.cos(a) * (depth + pattern);
                const z = baseZ - Math.sin(a) * (depth + pattern);
                points.push(new THREE.Vector3(x * scale, y * scale, z * scale));
              }
            }
          }
        }

        // Iconic steep stairs on all four sides
        for (let side = 0; side < 4; side++) {
          const stairAngle = (side / 4) * Math.PI * 2;

          // Main ceremonial stairway (very steep, as in real Angkor Wat)
          for (let step = 0; step < 20; step++) {
            const stepR = 38 + step * 0.4;
            const stepY = -17 + step * 0.6; // Steep rise

            // Central stairs are wider
            for (let w = -4; w <= 4; w += 0.3) {
              const x =
                Math.cos(stairAngle) * stepR +
                Math.cos(stairAngle + Math.PI / 2) * w;
              const z =
                Math.sin(stairAngle) * stepR +
                Math.sin(stairAngle + Math.PI / 2) * w;

              // Step surface
              points.push(
                new THREE.Vector3(x * scale, stepY * scale, z * scale)
              );

              // Step riser
              if (step > 0) {
                for (let rh = -0.6; rh < 0; rh += 0.1) {
                  points.push(
                    new THREE.Vector3(
                      x * scale,
                      (stepY + rh) * scale,
                      z * scale
                    )
                  );
                }
              }
            }

            // Lion guardians at base of stairs
            if (step === 0) {
              for (let lionSide = -1; lionSide <= 1; lionSide += 2) {
                const lionX =
                  Math.cos(stairAngle) * stepR +
                  Math.cos(stairAngle + Math.PI / 2) * lionSide * 5;
                const lionZ =
                  Math.sin(stairAngle) * stepR +
                  Math.sin(stairAngle + Math.PI / 2) * lionSide * 5;

                // Lion body (simplified)
                for (let lb = 0; lb < 50; lb++) {
                  const lx = lionX + (Math.random() - 0.5) * 2;
                  const ly = stepY + Math.random() * 3;
                  const lz = lionZ + (Math.random() - 0.5) * 2;
                  points.push(
                    new THREE.Vector3(lx * scale, ly * scale, lz * scale)
                  );
                }
              }
            }
          }
        }

        // Long causeway approaching from the west
        const causewayLength = 30;
        const causewayWidth = 6;
        for (let d = 0; d < causewayLength; d += 0.5) {
          const cx = -(38 + d);
          for (let w = -causewayWidth / 2; w <= causewayWidth / 2; w += 0.3) {
            // Causeway surface
            const cy = -17.5 + Math.sin(d * 0.1) * 0.1; // Slight undulation
            points.push(new THREE.Vector3(cx * scale, cy * scale, w * scale));

            // Raised edges
            if (Math.abs(w) > causewayWidth / 2 - 0.5) {
              for (let h = 0; h < 0.5; h += 0.1) {
                points.push(
                  new THREE.Vector3(cx * scale, (cy + h) * scale, w * scale)
                );
              }
            }
          }

          // Small nagas along causeway edges
          if (d % 5 === 0) {
            for (let side = -1; side <= 1; side += 2) {
              const nagaY = -17;
              const nagaZ = side * (causewayWidth / 2 + 1);
              for (let n = 0; n < 20; n++) {
                const nx = cx + (Math.random() - 0.5) * 1;
                const ny = nagaY + Math.random() * 1.5;
                const nz = nagaZ + (Math.random() - 0.5) * 0.5;
                points.push(
                  new THREE.Vector3(nx * scale, ny * scale, nz * scale)
                );
              }
            }
          }
        }

        // Gopura (entrance pavilions) at cardinal points
        const gopuras = [
          { x: -38, z: 0, orientation: 0 },
          { x: 38, z: 0, orientation: Math.PI },
          { x: 0, z: -38, orientation: Math.PI / 2 },
          { x: 0, z: 38, orientation: -Math.PI / 2 },
        ];

        for (let gopura of gopuras) {
          // Gopura entrance structure (without tower to maintain 5-tower count)
          for (let gx = -4; gx <= 4; gx += 0.3) {
            for (let gz = -2.5; gz <= 2.5; gz += 0.3) {
              const rotX =
                gopura.x +
                Math.cos(gopura.orientation) * gx -
                Math.sin(gopura.orientation) * gz;
              const rotZ =
                gopura.z +
                Math.sin(gopura.orientation) * gx +
                Math.cos(gopura.orientation) * gz;

              for (let gy = -14; gy < -14 + 8; gy += 0.3) {
                // Create entrance gateway with opening in center
                const isWall =
                  Math.abs(gx) > 3 ||
                  Math.abs(gz) > 1.5 ||
                  (Math.abs(gx) > 1 && (gy < -13 || gy > -8));
                if (isWall) {
                  points.push(
                    new THREE.Vector3(rotX * scale, gy * scale, rotZ * scale)
                  );
                }
              }

              // Decorative roof structure (not a full tower)
              if (Math.abs(gx) < 4 && Math.abs(gz) < 2.5) {
                for (let roofLevel = 0; roofLevel < 3; roofLevel++) {
                  const roofY = -6 + roofLevel * 0.5;
                  const roofInset = roofLevel * 0.5;
                  if (
                    Math.abs(gx) < 4 - roofInset &&
                    Math.abs(gz) < 2.5 - roofInset
                  ) {
                    points.push(
                      new THREE.Vector3(
                        rotX * scale,
                        roofY * scale,
                        rotZ * scale
                      )
                    );
                  }
                }
              }
            }
          }
        }

        distributePointsToParticles(points);
      }

      function generateNaga() {
        const points = [];
        const scale = 1.2;

        // Cambodian 7-headed Naga (serpent dragon)
        // Main serpent body (sinuous, curved)
        const bodyLength = 50;
        const bodySegments = 200;
        const bodyRadius = 2.5;

        // Create sinuous body curve
        for (let i = 0; i < bodySegments; i++) {
          const t = i / bodySegments;
          const x = (t - 0.5) * bodyLength;

          // Create S-curve with multiple waves
          const wave1 = Math.sin(t * Math.PI * 3) * 8;
          const wave2 = Math.sin(t * Math.PI * 5 + Math.PI / 3) * 4;
          const z = wave1 + wave2;

          // Body rises toward the heads
          const y = Math.sin(t * Math.PI * 0.5) * 3 + t * 8;

          // Body radius varies along length
          const currentRadius =
            bodyRadius * (0.8 + 0.4 * Math.sin(t * Math.PI));

          // Create cylindrical body segments
          const rings = 12;
          for (let ring = 0; ring < rings; ring++) {
            const angle = (ring / rings) * Math.PI * 2;
            const bodyX = x + Math.cos(angle) * currentRadius;
            const bodyY = y + Math.sin(angle) * currentRadius * 0.6; // Slightly flattened
            const bodyZ = z;

            points.push(
              new THREE.Vector3(bodyX * scale, bodyY * scale, bodyZ * scale)
            );

            // Add scales texture
            if (i % 3 === 0 && ring % 2 === 0) {
              const scaleSize = 0.3;
              for (let s = 0; s < 3; s++) {
                points.push(
                  new THREE.Vector3(
                    (bodyX + (Math.random() - 0.5) * scaleSize) * scale,
                    (bodyY + (Math.random() - 0.5) * scaleSize) * scale,
                    (bodyZ + (Math.random() - 0.5) * scaleSize) * scale
                  )
                );
              }
            }
          }

          // Spinal ridge
          if (i % 2 === 0) {
            const ridgeHeight = 0.8;
            points.push(
              new THREE.Vector3(
                x * scale,
                (y + currentRadius + ridgeHeight) * scale,
                z * scale
              )
            );
          }
        }

        // Seven heads arranged in a fan formation
        const headCount = 7;
        const headSpacing = 6;
        const headBaseY = bodyLength * 0.08 + 8; // At the raised end of the body
        const headBaseX = bodyLength * 0.4;
        const headBaseZ = 0;

        for (let h = 0; h < headCount; h++) {
          const headIndex = h - Math.floor(headCount / 2); // Center the heads
          const headAngle = (headIndex / headCount) * Math.PI * 0.8; // Fan spread
          const headDistance = Math.abs(headIndex) * headSpacing + 8;

          const headX = headBaseX + Math.cos(headAngle) * headDistance;
          const headZ = headBaseZ + Math.sin(headAngle) * headDistance;
          const headY = headBaseY + Math.abs(headIndex) * 2; // Middle head highest

          // Neck connecting to body
          const neckLength = 8;
          const neckSegments = 20;

          for (let n = 0; n < neckSegments; n++) {
            const neckT = n / neckSegments;
            const neckRadius = 1.5 * (1 - neckT * 0.3);

            // Neck curve
            const neckX = headBaseX + (headX - headBaseX) * neckT;
            const neckY =
              headBaseY +
              (headY - headBaseY) * neckT +
              Math.sin(neckT * Math.PI) * 2;
            const neckZ = headBaseZ + (headZ - headBaseZ) * neckT;

            // Neck segments
            const neckRings = 8;
            for (let ring = 0; ring < neckRings; ring++) {
              const angle = (ring / neckRings) * Math.PI * 2;
              const nx = neckX + Math.cos(angle) * neckRadius;
              const ny = neckY + Math.sin(angle) * neckRadius * 0.7;
              const nz = neckZ;

              points.push(
                new THREE.Vector3(nx * scale, ny * scale, nz * scale)
              );
            }
          }

          // Dragon head structure
          const headLength = 4;
          const headWidth = 2.5;
          const headHeight = 2;

          // Head main structure
          for (let x = -headLength / 2; x <= headLength / 2; x += 0.2) {
            for (let y = -headHeight / 2; y <= headHeight / 2; y += 0.2) {
              for (let z = -headWidth / 2; z <= headWidth / 2; z += 0.2) {
                // Head shape (elongated, tapered)
                const headFactor = 1 - Math.abs(x) / (headLength / 2);
                const currentWidth = headWidth * headFactor;
                const currentHeight = headHeight * headFactor;

                if (
                  Math.abs(y) <= currentHeight / 2 &&
                  Math.abs(z) <= currentWidth / 2
                ) {
                  const headPointX =
                    headX + x * Math.cos(headAngle) - z * Math.sin(headAngle);
                  const headPointY = headY + y;
                  const headPointZ =
                    headZ + x * Math.sin(headAngle) + z * Math.cos(headAngle);

                  points.push(
                    new THREE.Vector3(
                      headPointX * scale,
                      headPointY * scale,
                      headPointZ * scale
                    )
                  );
                }
              }
            }
          }

          // Eyes (prominent and fierce)
          const eyePositions = [
            { x: headLength / 3, y: headHeight / 4, z: headWidth / 3 },
            { x: headLength / 3, y: headHeight / 4, z: -headWidth / 3 },
          ];

          for (let eye of eyePositions) {
            const eyeRadius = 0.4;
            const eyeSegments = 12;

            for (let e = 0; e < eyeSegments; e++) {
              const eyeAngle = (e / eyeSegments) * Math.PI * 2;
              const eyeX =
                headX +
                (eye.x * Math.cos(headAngle) - eye.z * Math.sin(headAngle)) +
                Math.cos(eyeAngle) * eyeRadius;
              const eyeY = headY + eye.y + Math.sin(eyeAngle) * eyeRadius;
              const eyeZ =
                headZ +
                (eye.x * Math.sin(headAngle) + eye.z * Math.cos(headAngle));

              points.push(
                new THREE.Vector3(eyeX * scale, eyeY * scale, eyeZ * scale)
              );

              // Eye detail
              if (e % 3 === 0) {
                points.push(
                  new THREE.Vector3(
                    (eyeX + Math.cos(eyeAngle) * 0.2) * scale,
                    (eyeY + Math.sin(eyeAngle) * 0.2) * scale,
                    eyeZ * scale
                  )
                );
              }
            }
          }

          // Nostrils
          const nostrilPositions = [
            { x: headLength / 2 - 0.3, y: 0, z: 0.3 },
            { x: headLength / 2 - 0.3, y: 0, z: -0.3 },
          ];

          for (let nostril of nostrilPositions) {
            const nostrilX =
              headX +
              (nostril.x * Math.cos(headAngle) -
                nostril.z * Math.sin(headAngle));
            const nostrilY = headY + nostril.y;
            const nostrilZ =
              headZ +
              (nostril.x * Math.sin(headAngle) +
                nostril.z * Math.cos(headAngle));

            // Small nostril opening
            for (let n = 0; n < 8; n++) {
              const nAngle = (n / 8) * Math.PI * 2;
              const nRadius = 0.15;
              points.push(
                new THREE.Vector3(
                  (nostrilX + Math.cos(nAngle) * nRadius) * scale,
                  (nostrilY + Math.sin(nAngle) * nRadius) * scale,
                  nostrilZ * scale
                )
              );
            }
          }

          // Mouth and fangs
          const mouthLength = headLength * 0.6;
          const mouthWidth = headWidth * 0.8;

          // Mouth opening
          for (let m = 0; m < mouthLength; m += 0.2) {
            const mouthT = m / mouthLength;
            const currentMouthWidth = mouthWidth * (1 - mouthT * 0.3);

            for (let side = -1; side <= 1; side += 2) {
              const mouthX =
                headX + (m - mouthLength / 2) * Math.cos(headAngle);
              const mouthY = headY - 0.3;
              const mouthZ =
                headZ +
                (m - mouthLength / 2) * Math.sin(headAngle) +
                (side * currentMouthWidth) / 2;

              points.push(
                new THREE.Vector3(
                  mouthX * scale,
                  mouthY * scale,
                  mouthZ * scale
                )
              );
            }
          }

          // Fangs
          const fangPositions = [
            { x: headLength / 4, z: headWidth / 4 },
            { x: headLength / 4, z: -headWidth / 4 },
            { x: headLength / 3, z: headWidth / 6 },
            { x: headLength / 3, z: -headWidth / 6 },
          ];

          for (let fang of fangPositions) {
            const fangLength = 1.2;
            const fangSegments = 8;

            for (let f = 0; f < fangSegments; f++) {
              const fangT = f / fangSegments;
              const fangRadius = 0.1 * (1 - fangT);

              const fangX =
                headX +
                (fang.x * Math.cos(headAngle) - fang.z * Math.sin(headAngle));
              const fangY = headY - fangT * fangLength;
              const fangZ =
                headZ +
                (fang.x * Math.sin(headAngle) + fang.z * Math.cos(headAngle));

              // Fang tip detail
              for (let ring = 0; ring < 4; ring++) {
                const ringAngle = (ring / 4) * Math.PI * 2;
                points.push(
                  new THREE.Vector3(
                    (fangX + Math.cos(ringAngle) * fangRadius) * scale,
                    fangY * scale,
                    (fangZ + Math.sin(ringAngle) * fangRadius) * scale
                  )
                );
              }
            }
          }

          // Head crest/crown (traditional Khmer style)
          if (h === Math.floor(headCount / 2)) {
            // Central head gets the crown
            const crownHeight = 3;
            const crownWidth = headWidth * 1.5;
            const crownSegments = 20;

            for (let c = 0; c < crownSegments; c++) {
              const crownAngle = (c / crownSegments) * Math.PI * 2;
              const crownRadius =
                (crownWidth / 2) * (1 + 0.3 * Math.sin(crownAngle * 3)); // Ornate edge

              for (let h = 0; h < crownHeight; h += 0.2) {
                const currentRadius =
                  crownRadius * (1 - (h / crownHeight) * 0.4);
                const crownX =
                  headX + Math.cos(crownAngle + headAngle) * currentRadius;
                const crownY = headY + headHeight / 2 + h;
                const crownZ =
                  headZ + Math.sin(crownAngle + headAngle) * currentRadius;

                points.push(
                  new THREE.Vector3(
                    crownX * scale,
                    crownY * scale,
                    crownZ * scale
                  )
                );
              }
            }

            // Crown decorative spikes
            const spikes = 7;
            for (let s = 0; s < spikes; s++) {
              const spikeAngle = (s / spikes) * Math.PI * 2;
              const spikeHeight = 2;
              const spikeSegments = 10;

              for (let seg = 0; seg < spikeSegments; seg++) {
                const spikeT = seg / spikeSegments;
                const spikeRadius = 0.1 * (1 - spikeT);

                const spikeX =
                  headX + (Math.cos(spikeAngle + headAngle) * crownWidth) / 2;
                const spikeY =
                  headY + headHeight / 2 + crownHeight + spikeT * spikeHeight;
                const spikeZ =
                  headZ + (Math.sin(spikeAngle + headAngle) * crownWidth) / 2;

                for (let ring = 0; ring < 4; ring++) {
                  const ringAngle = (ring / 4) * Math.PI * 2;
                  points.push(
                    new THREE.Vector3(
                      (spikeX + Math.cos(ringAngle) * spikeRadius) * scale,
                      spikeY * scale,
                      (spikeZ + Math.sin(ringAngle) * spikeRadius) * scale
                    )
                  );
                }
              }
            }
          }
        }

        // Decorative fins along the body
        const finCount = 15;
        for (let f = 0; f < finCount; f++) {
          const finT = (f / finCount) * 0.8 + 0.1; // Along most of the body
          const finX = (finT - 0.5) * bodyLength;
          const finZ =
            Math.sin(finT * Math.PI * 3) * 8 +
            Math.sin(finT * Math.PI * 5 + Math.PI / 3) * 4;
          const finY = Math.sin(finT * Math.PI * 0.5) * 3 + finT * 8;

          const finHeight = 2 + Math.sin(finT * Math.PI * 2) * 1;
          const finWidth = 1.5;

          // Dorsal fin
          for (let h = 0; h < finHeight; h += 0.2) {
            for (let w = -finWidth / 2; w <= finWidth / 2; w += 0.2) {
              const finPointX = finX + w;
              const finPointY = finY + bodyRadius + h;
              const finPointZ = finZ;

              points.push(
                new THREE.Vector3(
                  finPointX * scale,
                  finPointY * scale,
                  finPointZ * scale
                )
              );
            }
          }
        }

        distributePointsToParticles(points);
      }

      function distributePointsToParticles(points) {
        // Ensure we have enough points
        while (points.length < PARTICLE_COUNT) {
          points.push(
            points[Math.floor(Math.random() * points.length)].clone()
          );
        }

        // Shuffle points for better distribution
        for (let i = points.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [points[i], points[j]] = [points[j], points[i]];
        }

        // Assign to particles
        for (let i = 0; i < PARTICLE_COUNT; i++) {
          const point = points[i % points.length];
          targetPositions[i * 3] = point.x;
          targetPositions[i * 3 + 1] = point.y;
          targetPositions[i * 3 + 2] = point.z;
        }
      }

      function initEventListeners() {
        // Shape buttons
        document.querySelectorAll(".button").forEach((button) => {
          button.addEventListener("click", (e) => {
            if (selectedButton) {
              selectedButton.classList.remove("active");
            }
            selectedButton = e.target;
            selectedButton.classList.add("active");

            const shape = e.target.dataset.shape;
            morphToShape(shape);
          });
        });

        // Controls
        document
          .getElementById("particleSize")
          .addEventListener("input", (e) => {
            params.particleSize = parseFloat(e.target.value);
            particleMaterial.uniforms.uSize.value = params.particleSize;
            document.getElementById("sizeValue").textContent =
              params.particleSize.toFixed(1);
          });

        document
          .getElementById("rotationSpeed")
          .addEventListener("input", (e) => {
            params.rotationSpeed = parseFloat(e.target.value);
            document.getElementById("speedValue").textContent =
              params.rotationSpeed.toFixed(1);
          });

        document
          .getElementById("particleColor")
          .addEventListener("input", (e) => {
            params.particleColor.set(e.target.value);
            particleMaterial.uniforms.uColor.value = params.particleColor;
          });

        document
          .getElementById("bloomStrength")
          .addEventListener("input", (e) => {
            params.bloomStrength = parseFloat(e.target.value);
            bloomPass.strength = params.bloomStrength;
            document.getElementById("bloomValue").textContent =
              params.bloomStrength.toFixed(1);
          });

        document
          .getElementById("motionTrail")
          .addEventListener("input", (e) => {
            params.motionTrail = parseFloat(e.target.value);
            document.getElementById("trailValue").textContent =
              params.motionTrail.toFixed(2);
          });

        // Window resize
        window.addEventListener("resize", onWindowResize);

        // Double-click reset
        renderer.domElement.addEventListener("dblclick", () => {
          controls.reset();
        });
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        previousRenderTarget.setSize(window.innerWidth, window.innerHeight);
      }

      function updateMorphing(deltaTime) {
        if (!isMorphing) return;

        morphProgress += deltaTime * 0.5; // Morph speed - slower transition
        if (morphProgress >= 1.0) {
          morphProgress = 1.0;
          isMorphing = false;
        }

        // Smooth easing function
        const eased = 1 - Math.pow(1 - morphProgress, 3);

        // Update particle positions
        const positions = particleSystem.geometry.attributes.position.array;
        for (let i = 0; i < positions.length; i++) {
          positions[i] =
            originalPositions[i] +
            (targetPositions[i] - originalPositions[i]) * eased;
        }
        particleSystem.geometry.attributes.position.needsUpdate = true;

        particleMaterial.uniforms.uMorphProgress.value = eased;
      }

      function animate() {
        requestAnimationFrame(animate);

        const deltaTime = clock.getDelta();
        const elapsedTime = clock.getElapsedTime();

        // Update controls
        controls.update();

        // Update particle system
        if (particleSystem) {
          particleSystem.rotation.y += params.rotationSpeed * deltaTime;
          particleMaterial.uniforms.uTime.value = elapsedTime;
          updateMorphing(deltaTime);
        }

        // Store current frame for motion blur
        renderer.setRenderTarget(previousRenderTarget);
        renderer.render(scene, camera);
        renderer.setRenderTarget(null);

        // Update motion blur uniform
        if (composer.passes[3]) {
          composer.passes[3].uniforms.uBlendFactor.value = params.motionTrail;
        }

        // Render with post-processing
        composer.render();
      }
    </script>
  </body>
</html>
